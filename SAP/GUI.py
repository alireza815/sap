#!/usr/bin/env python
# -*- coding: us-ascii -*-
# generated by wxGlade 0.5 on Tue Jun 26 11:07:06 2007

# Wizard for downloading and installing missing dependencies
# MVCTreeOverView for illustrating taxonomy summaries

# py2applet --make-setup gui.py
# python setup.py py2app -A --use-pythonpath
# python setup.py py2app --use-pythonpath

# Standard libs:
try:
   import cPickle as pickle
except:
   import pickle
import sys, re, os, copy, time, glob, traceback
from optparse import OptionParser
from math import floor

# BioPython modules:
from SAP.Bio.Nexus import Nexus, Trees, Nodes

import Fasta

# Custom modules:
#import SAP
import NeighbourJoin
import MachinePool
import Options
from XML2Obj import XML2Obj
from Homology import HomolCompiler, HomologySet, Homologue
from TreeStatistics import TreeStatistics
# from ClustalWrapper import ClustalWrapper
# from MrBayesWrapper import MrBayesWrapper
# from BarcoderWrapper import BarcoderWrapper
# from NeighbourJoinWrapper import NeighbourJoinWrapper
from PairWiseDiffs import PairWiseDiffs
from ResultHTML import ResultHTML
from Initialize import Initialize

# We need to import these here so py2app can map them as dependencies:
from SAP.Sampling import Barcoder, ConstrainedNJ
from SAP.Alignment import Clustalw2
        
from UtilityFunctions import *
from InstallDependencies import *

import sys, os, time
import wx
import wx.lib.rcsizer  as rcs
import wx.lib.scrolledpanel as scrolled
import wx.lib.filebrowsebutton as filebrowse
from wx.lib.mixins.listctrl import CheckListCtrlMixin
from wx.lib.wordwrap import wordwrap
import wx.lib.delayedresult as delayedresult
import wx.lib.hyperlink as hyperlink
#----------------------------------------------------------------------
# We first have to set an application-wide help provider.  Normally you
# would do this in your app's OnInit or in other startup code...
provider = wx.SimpleHelpProvider()
wx.HelpProvider_Set(provider)

wildcard = "Fasta files (*.fasta)|*.fasta|"     \
           "All files (*.*)|*.*"

# optionParser = None
# sys.argv = [None]
optionParser = Options.Options()
optionParser.options.project = ''

import Queue
outputQueue = Queue.Queue()


class MyDropTarget(wx.FileDropTarget):
    def __init__(self, window, textctrl):
        wx.FileDropTarget.__init__(self)
        self.window = window
        self.textctrl = textctrl

    def typeErrorDialog(self, text):
        dlg = wx.MessageDialog(self.window, text, 'Type error.', wx.OK | wx.ICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()

class MyFileDropTarget(MyDropTarget):

   def OnDropFiles(self, x, y, filenames):
       for f in filenames:
           if not os.path.isfile(f):
               self.typeErrorDialog('%s is not a file.' % f)
               return
           if f.find(" ") > 0:
               self.typeErrorDialog('File name: %s constains space characters.' % f)
               return
       self.textctrl.SetInsertionPointEnd()
       self.textctrl.WriteText("\n".join(filenames) + "\n")


class MyDirDropTarget(MyDropTarget):

   def OnDropFiles(self, x, y, filenames):
       for f in filenames:
          if not os.path.isdir(f):
             self.typeErrorDialog('%s is not a directory.' % f)
             return
       self.textctrl.SetInsertionPointEnd()
       self.textctrl.WriteText(" ".join(filenames))


# class MyFileDropTarget(wx.FileDropTarget):
#     def __init__(self, window, textctrl):
#         wx.FileDropTarget.__init__(self)
#         self.window = window
#         self.textctrl = textctrl
# 
#     def OnDropFiles(self, x, y, filenames):
#         self.textctrl.SetInsertionPointEnd()
#         self.textctrl.WriteText(" ".join(filenames))

class OutputEnqueue:
    def __init__(self):
        pass
    def write(self, s):
        outputQueue.put(s)
    def flush(self):
        pass

class LogFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        self.log = LogWindow(self)

        self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnWindowDestroy)

    def OnCloseWindow(self, event):
        self.Hide()

    def OnWindowDestroy(self, event):
        self.Hide()

class LogWindow(wx.TextCtrl):
    def __init__ (self, frame):

        self.parent = frame

        wx.TextCtrl.__init__(self,self.parent,size=self.parent.GetClientSize(),
                             style=wx.TE_MULTILINE|wx.TE_READONLY|wx.HSCROLL)

        style = wx.TextAttr()
        style.SetFont(wx.Font(11, wx.SWISS, wx.NORMAL, wx.NORMAL, False, 'Verdana'))
        self.SetDefaultStyle(style)

        # Bind all EVT_TIMER events to self.OnTest1Timer
        self.Bind(wx.EVT_TIMER, self.onTimer)
        self.startTimer()

    def startTimer(self):
        self.timer1 = wx.Timer(self)
        self.timer1.Start(1000)

    def stopTimer(self):
        self.timer1.Stop()
        del self.timer1

    def onTimer(self, evt):
        output = []
        for s in self.getAllFromQueue(outputQueue):
            self.write(s)

    def getAllFromQueue(self, Q):
        """Generator to yield one after the others all item currently in
        the queue Q, without any waiting"""
        try:
            while True:
                yield Q.get_nowait()
        except Queue.Empty:
            raise StopIteration

    def flush(self):
        pass

class OptionsValidator(wx.PyValidator):
     """ This validator is used to ensure that the user has entered something
         into the text object editor dialog's text field.
     """
     def __init__(self, optionName):
         """ Standard constructor.
         """
         wx.PyValidator.__init__(self)

         self.optionName = optionName

     def Clone(self):
         """ Standard cloner.

             Note that every validator must implement the Clone() method.
         """
         return OptionsValidator(self.optionName)

     def Validate(self, win):
         """ Validate the contents of the given text control.
         """
         textCtrl = self.GetWindow()
         text = textCtrl.GetValue()

         inputError = False

         if text != '':
            # Find type of option and convert to that type
            origValue = getattr(optionParser.options, self.optionName)
            try:
               if type(origValue) == type(True):
                   if text == 'True':
                       newValue = True
                   elif text == 'False':
                       newValue = False
                   else:
                       inputError = True
               elif type(origValue) == type([]):
                  newValue = re.split(r'\s*,\s*', text)
                  if type(origValue[0]) == type(1):
                     newValue = [int(x) for x in newValue]
                  elif type(origValue[0]) == type(1.1):
                     newValue = [float(x) for x in newValue]
               elif type(origValue) == type(1.1):
                   newValue = float(text)
               elif type(origValue) == type(1):
                   newValue = int(text)
               else:
                   newValue = text
            except ValueError:
               inputError = True
         else:
            inputError = True

         # Make some sanity checks:
         if inputError:
             if text == '':
                msg = "You cannot leave input fields blank"
             else:
                msg = "Invalid input value: %s" % text
             wx.MessageBox(msg , "Input Error")
             textCtrl.SetBackgroundColour("pink")
             textCtrl.SetFocus()
             textCtrl.Refresh()
             return False
         else:
             setattr(optionParser.options, self.optionName, newValue)

             textCtrl.SetBackgroundColour(
                 wx.SystemSettings_GetColour(wx.SYS_COLOUR_WINDOW))
             textCtrl.Refresh()
             return True

     def TransferToWindow(self):
         """ Transfer data from validator to window.

             The default implementation returns False, indicating that an error
             occurred.  We simply return True, as we don't do any data transfer.
         """
         return True # Prevent wxDialog from complaining.

     def TransferFromWindow(self):
         """ Transfer data from window to validator.

             The default implementation returns False, indicating that an error
             occurred.  We simply return True, as we don't do any data transfer.
         """
         return True # Prevent wxDialog from complaining.
     

class BoundTextCtrl(wx.TextCtrl):
    def __init__ (self, parent, optionName):

        #wx.TextCtrl.__init__(self, parent, -1, str(getattr(optionParser.options, optionName)), size=(100, -1), validator=OptionsValidator(optionName))
        wx.TextCtrl.__init__(self, parent, -1, self.formatDefaultSring(optionParser, optionName), size=(100, -1), validator=OptionsValidator(optionName))

        self.Bind(wx.EVT_TEXT, self.EvtText)
        self.Bind(wx.EVT_CHAR, self.EvtChar)
        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_KILL_FOCUS, self.OnKillFocus)
        self.Bind(wx.EVT_WINDOW_DESTROY, self.OnWindowDestroy)

    def formatDefaultSring(self, optionParser, optionName):
       opt = getattr(optionParser.options, optionName)
       s = str(opt)
       if type(opt) == type([]):
          return s[1:-1]
       else:
          return s

    def EvtText(self, evt):
        varString = evt.GetString()

    def EvtTextEnter(self, evt):
        evt.Skip()

    def EvtChar(self, evt):
        evt.Skip()

    def OnSetFocus(self, evt):
        evt.Skip()

    def OnKillFocus(self, evt):
        evt.Skip()

    def OnWindowDestroy(self, evt):
        evt.Skip()


class OptionsDialog(wx.Dialog):
    def __init__(self, parent):
        wx.Dialog.__init__(self, parent, -1, "Options")

        global optionParser

        self.SetAutoLayout(True)

        # Sizer for the entire tab:
        #sizer = wx.BoxSizer(wx.VERTICAL)
        sizer = wx.BoxSizer(wx.HORIZONTAL)
        col1sizer = wx.BoxSizer(wx.VERTICAL)
        col2sizer = wx.BoxSizer(wx.VERTICAL)

        sizer.Add(col1sizer, 0, 0, 0)
        sizer.Add(col2sizer, 0, 0, 0)
        


        box1 = wx.StaticBox(self, -1, "Compilation of set of homologues")
        box1sizer = wx.StaticBoxSizer(box1, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box1GridSizer = wx.FlexGridSizer(cols=4, hgap=20, vgap=5)

        box1sizer.Add(box1GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col1sizer.Add(box1sizer, 0, wx.ALL, 10)

#         # Add grid sizer to box sizer:
#         sizer.Add(box1GridSizer, 0, 0, 0)

        objList = []

        usedList = ['--database',             '--harddiversity',
                    '--inputformat',          '--phyla',             
                    '--quickcompile',         '--classes',           
                    '--limitquery',           '--orders',            
                    '--nolowcomplexfilter',   '--families',          
                    '--maxblasthits',         '--genera',            
                    '--besthits',             '--individuals',       
                    '--alignmentlimit',       '--nofillin',           
                    '--relbitscore',          '--fillinall',         
                    '--evaluesignificance',   '--fillintomatch',     
                    '--minsignificant',       '--forceexcludegilist',
                    '--evaluecutoff',         '--forceincludegilist',  
                    '--minidentity',          '--forceidentity',                                             
                    '--subspecieslevel',      '--forceincludefile'                                               
                    ]

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])

        # Add the fields to the grid sizer:
        box1GridSizer.AddMany(objList)



        box2 = wx.StaticBox(self, -1, "Alignment")
        box2sizer = wx.StaticBoxSizer(box2, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box2GridSizer = wx.FlexGridSizer(cols=2, hgap=20, vgap=5)

        box2sizer.Add(box2GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col2sizer.Add(box2sizer, 0, wx.ALL, 10)

#         # Add grid sizer to box sizer:
#         sizer.Add(box2GridSizer, 0, 0, 0)

        objList = []

        usedList = ['--alignment', '--warnongaps', '--alignmentoption']

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])

        # Add the fields to the grid sizer:
        box2GridSizer.AddMany(objList)



        box3 = wx.StaticBox(self, -1, "Tree sampling and assignmnet statistics")
        box3sizer = wx.StaticBoxSizer(box3, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box3GridSizer = wx.FlexGridSizer(cols=2, hgap=20, vgap=5)

        box3sizer.Add(box3GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col2sizer.Add(box3sizer, 0, wx.ALL, 10)

#         # Add grid sizer to box sizer:
#         sizer.Add(box3GridSizer, 0, 0, 0)

        objList = []

        usedList = ['--prunelevel', '--sampler']

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])


        # Add the fields to the grid sizer:
        box3GridSizer.AddMany(objList)



        box4 = wx.StaticBox(self, -1, "Result formatting options")
        box4sizer = wx.StaticBoxSizer(box4, wx.VERTICAL)
        
        # grid sizer to go inside box sizer:
        box4GridSizer = wx.FlexGridSizer(cols=2, hgap=20, vgap=5)

        box4sizer.Add(box4GridSizer, 0, wx.TOP|wx.LEFT, 10)
        col2sizer.Add(box4sizer, 0, wx.ALL, 10)

#         # Add grid sizer to box sizer:
#         sizer.Add(box4GridSizer, 0, 0, 0)

        objList = []


        usedList = ['--ppcutoff', '--svg', '--cleanlook', '--diffs']

        for optionName in usedList:
            option = optionParser.parser.get_option(optionName)
            l = wx.StaticText(self, -1, "%s:" % option.dest, size=(130, -1))
            t = BoundTextCtrl(self, option.dest)
            l.SetHelpText(option.help)            
            objList.extend([l,t])


        # Add the fields to the grid sizer:
        box4GridSizer.AddMany(objList)





        border = wx.BoxSizer(wx.VERTICAL)

        cBtn = wx.ContextHelpButton(self)
        cBtn.SetHelpText("Click the question mark and THEN the option name you need help on.")
        cBtnText = wx.StaticText(self, -1, "Click the question mark and then the option name you need help on.")

        helpBox = wx.BoxSizer(wx.HORIZONTAL)
        helpBox.Add(cBtn, 0, wx.ALL, 5)
        helpBox.Add(cBtnText, 0, wx.ALL, 5)
        border.Add(helpBox, 0, wx.ALL, 5)

        border.Add(sizer, 1, wx.GROW|wx.ALL, 10)
        
        # Ok and cancel buttons:
        buttons = wx.StdDialogButtonSizer()
        b = wx.Button(self, wx.ID_OK, "OK")
        b.SetDefault()
        buttons.AddButton(b)
        buttons.AddButton(wx.Button(self, wx.ID_CANCEL, "Cancel"))
        buttons.Realize()

        border.Add(buttons, 0, wx.ALIGN_RIGHT)
        border.Add((10,10))

        self.SetSizer(border)
        border.Fit(self)
        self.Layout()

class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)

        self.webSite = "http://ib.berkeley.edu/labs/slatkin/munch/StatisticalAssignmentPackage.html"
        # Frame title
        self.SetTitle("Statistical Assignment Package")

        self.logframe = LogFrame(self, -1, "Log", size=(700, 500))


#         MenuBar = wx.MenuBar()
# 
#         FileMenu = wx.Menu()
#         
#         item = FileMenu.Append(wx.ID_EXIT, text = "&Exit")
#         self.Bind(wx.EVT_MENU, self.OnQuit, item)
# 
#         item = FileMenu.Append(wx.ID_ANY, text = "&Open")
#         self.Bind(wx.EVT_MENU, self.OnOpen, item)
# 
#         item = FileMenu.Append(wx.ID_PREFERENCES, text = "&Preferences")
#         self.Bind(wx.EVT_MENU, self.OnPrefs, item)
# 
#         MenuBar.Append(FileMenu, "&File")
#         
#         HelpMenu = wx.Menu()
# 
#         item = HelpMenu.Append(wx.ID_HELP, "Test &Help",
#                                 "Help for this simple test")
#         self.Bind(wx.EVT_MENU, self.OnHelp, item)
# 
#         ## this gets put in the App menu on OS-X
#         item = HelpMenu.Append(wx.ID_ABOUT, "&About",
#                                 "More information About this program")
#         self.Bind(wx.EVT_MENU, self.OnAbout, item)
#         MenuBar.Append(HelpMenu, "&Help")
# 
#         self.SetMenuBar(MenuBar)
# 
#         btn = wx.Button(self, label = "Quit")
# 
#         btn.Bind(wx.EVT_BUTTON, self.OnQuit )
# 
#         self.Bind(wx.EVT_CLOSE, self.OnQuit)

        # Prepare the menu bar
        menuBar = wx.MenuBar()
        # 1st menu from left
        menu1 = wx.Menu()
        menu1.Append(102, "Open project\tCtrl+O")
        # Add menu to the menu bar
        menuBar.Append(menu1, "File")
        # Shortcuts
        menu2 = wx.Menu()
        menu2.Append(201, "Results\tCtrl+R", "Open results in browser window")
        ## menu2.Append(202, "Options\tShift+O")
        menu2.Append(203, "Log\tShift+L")
        menuBar.Append(menu2, "&View")
        # Help
        menu3 = wx.Menu()
        menu3.Append(301, "Online Manual\tCtrl+H")
        menu3.AppendSeparator()
        menu3.Append(302, "About")
        menuBar.Append(menu3, "&Help")

        self.SetMenuBar(menuBar)

        self.Bind(wx.EVT_MENU, self.openProject, id=102)        
        self.Bind(wx.EVT_MENU, self.showResults, id=201)
        ## self.Bind(wx.EVT_MENU, self.onOptionsButton, id=202)
        self.Bind(wx.EVT_MENU, self.menu203, id=203)
        self.Bind(wx.EVT_MENU, self.menu301, id=301)
        self.Bind(wx.EVT_MENU, self.menu302, id=302)

#         self.Bind(wx.EVT_WINDOW_DESTROY, self.OnWindowDestroy)

        self.resultPath = None

        self.jobID = 0
        self.abortEvent = delayedresult.AbortEvent()
        
        self.panel = panel = scrolled.ScrolledPanel(self, -1, style = wx.TAB_TRAVERSAL, name="panel1" )

        # Sizer for the entire tab:
        tabSizer = wx.BoxSizer(wx.VERTICAL)

        topText = "Specify sequence file (Fasta format) and project directory for project files:"
        tabSizer.Add(wx.StaticText(panel, -1, topText), 0, wx.ALL, 10)

        # Make a sizer for the top input fields and add it to the top sizer with a bit of margin:
        topGridSizer = wx.FlexGridSizer(cols=3, hgap=14, vgap=14)
        tabSizer.Add(topGridSizer, 1, wx.EXPAND|wx.ALL, 10)

#         self.l1 = l1 = wx.StaticText(panel, -1, "Sequence:")
#         self.t1 = t1 = wx.TextCtrl(panel, -1, "", size=(350, 120), style=wx.TE_MULTILINE)
#         dt1 = MyFileDropTarget(self, t1)
#         self.t1.SetDropTarget(dt1)
#         wx.CallAfter(t1.SetInsertionPoint, 0)
# 
#         self.l2 = l2 = wx.StaticText(panel, -1, "Sequence file:")
#         #self.t2 = t2 = wx.TextCtrl(panel, -1, "", size=(350, -1))
#         self.t2 = t2 = wx.TextCtrl(panel, -1, "", size=(350, 50), style=wx.TE_MULTILINE)
#         dt2 = MyFileDropTarget(self, t2)
#         self.t2.SetDropTarget(dt2)
#         self.b2 = b2 = wx.Button(panel, -1, "Browse")
#         self.Bind(wx.EVT_BUTTON, self.onFileBrowseButton, b2)
#         wx.CallAfter(t2.SetInsertionPoint, 0)
# 
# 
#         self.l3 = l3 = wx.StaticText(panel, -1, "Project folder:")
#         self.t3 = t3 = wx.TextCtrl(panel, -1, "", size=(350, -1))
#         dt3 = MyDirDropTarget(self, t3)
#         self.t3.SetDropTarget(dt3)
#         self.b3 = b3 = wx.Button(panel, -1, "Browse")
#         self.Bind(wx.EVT_BUTTON, self.onDirBrowseButton, b3)
#         wx.CallAfter(t3.SetInsertionPoint, 0)
# 
#         self.runB = runB = wx.Button(panel, -1, "Run")        
#         runB.SetDefault()
#         self.Bind(wx.EVT_BUTTON, self.onRunButton, runB)
# 
#         self.abortB = abortB = wx.Button(panel, -1, "Abort")        
#         abortB.Enable(False)
#         self.Bind(wx.EVT_BUTTON, self.onAbortButton, abortB)
# 
#         self.optionsB = optionsB = wx.Button(panel, -1, "Options")        
#         self.Bind(wx.EVT_BUTTON, self.onOptionsButton, optionsB)
# 
#         topGridSizer.AddMany([ l1, t1, (0,0),
#                                l2, t2, b2,
#                                l3, t3, b3,
#                                (0,0), (0,0,), (0,0,),
#                                optionsB, (0,0,), runB,
#                                (0,0,), (0,0,), abortB
#                                ])

        self.l1 = l1 = wx.StaticText(panel, -1, "Sequence files:")
        self.t1 = t1 = wx.TextCtrl(panel, -1, "", size=(350, 50), style=wx.TE_MULTILINE)
        #self.t1 = t1 = wx.TextCtrl(panel, -1, "", size=(350, -1))
        dt1 = MyFileDropTarget(self, t1)
        self.t1.SetDropTarget(dt1)
        self.b1 = b1 = wx.Button(panel, -1, "Browse")
        self.Bind(wx.EVT_BUTTON, self.onFileBrowseButton, b1)
        wx.CallAfter(t1.SetInsertionPoint, 0)

        self.l2 = l2 = wx.StaticText(panel, -1, "Project folder:")
        self.t2 = t2 = wx.TextCtrl(panel, -1, "", size=(350, -1))
        dt2 = MyDirDropTarget(self, t2)
        self.t2.SetDropTarget(dt2)
        self.b2 = b2 = wx.Button(panel, -1, "Browse")
        self.Bind(wx.EVT_BUTTON, self.onDirBrowseButton, b2)
        wx.CallAfter(t2.SetInsertionPoint, 0)

        self.runB = runB = wx.Button(panel, -1, "Run")        
        runB.SetDefault()
        self.Bind(wx.EVT_BUTTON, self.onRunButton, runB)

        self.abortB = abortB = wx.Button(panel, -1, "Abort")        
        abortB.Enable(False)
        self.Bind(wx.EVT_BUTTON, self.onAbortButton, abortB)

        self.optionsB = optionsB = wx.Button(panel, -1, "Options")        
        self.Bind(wx.EVT_BUTTON, self.onOptionsButton, optionsB)

        topGridSizer.AddMany([ l1, t1, b1,
                               l2, t2, b2,
                               (0,0), (0,0,), (0,0,),
                               optionsB, (0,0,), runB,
                               (0,0,), (0,0,), abortB
                               ])

        panel.SetSizer(tabSizer)
        panel.SetAutoLayout(True)
        panel.SetupScrolling()

        # Frame sizer:
        frameSizer = wx.BoxSizer(wx.VERTICAL)    
        frameSizer.SetMinSize((595, 260))
        # Add the note book to the frame sizer:
        frameSizer.Add(panel, 1, wx.EXPAND|wx.ALL, 10)
        # Set the frame sizer:
        self.SetSizer(frameSizer)
        # Fit the frame sizer to the frame:
        frameSizer.Fit(self)

        self.Layout()
    
    def openProject(self, evt):

        projectWildcard = "SAP projects (*.sap)|*.sap|"     \
                   "All files (*.*)|*.*"

        dlg = wx.FileDialog(
            self, message="Choose *.sap file in the directory of the project you want to open.",
            defaultDir=os.getcwd(), 
            defaultFile="",
            wildcard=projectWildcard,
            style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR
            )

        if dlg.ShowModal() == wx.ID_OK:
            paths = dlg.GetPaths()
            optionsFile = paths[0]
            # Load options into parser:
            pickleFile = open(optionsFile, 'r')
            optionParser.options = pickle.load(pickleFile)
            pickleFile.close()
            self.t2.SetValue(optionParser.options.project)

            # Get names of input files and Update input file field:
            globExpr = os.path.join(optionParser.options.datadir, '*.fasta')
            inputFiles = glob.glob(globExpr)
            self.t1.SetValue(" ".join(inputFiles))

        dlg.Destroy()

    def OnWindowDestroy(self, evt):

       if self.abortB.IsEnabled():
          dlg = wx.MessageDialog(self, "Want to exit?", "Exit", wx.YES_NO | wx.ICON_QUESTION)

          if dlg.ShowModal() == wx.ID_YES:
             self.Close(True)
             self.Destroy() # frame
#              dlg.Destroy()

       else:
          self.Close(True)

    def _resultProducer(self, jobID, abortEvent, inputFiles):

        try:
            sys.stdout = OutputEnqueue()
    
            global optionParser
    
            # Make directories and write fixed inputfiles:
            init = Initialize(optionParser.options)
            init.createDirs()
    
            inputFiles, seqCount, sequenceNameMap = init.fixAndMoveInput(inputFiles)
            init.checkCacheConsistency(inputFiles)
        
            fastaFileBaseNames = []
    
#             try:
#                plugin = findPlugin('Clustalw2', 'SAP.alignment')
#             except PluginNotFoundError:
#                from SAP.Alignment import Clustalw2 as plugin
#             aligner = plugin.Aligner(optionParser.options)
# 
#             try:
#                plugin = findPlugin('Barcoder', 'SAP.sampler')
#             except PluginNotFoundError:
#                from SAP.Sampling import Barcoder as plugin
#             sampler = plugin.Sampler(optionParser.options)

            try:
               plugin = findPlugin(optionParser.options.alignment, 'SAP.alignment')
            except PluginNotFoundError:
               exec("from SAP.Alignment import %s as plugin" % optionParser.options.alignment)
            aligner = plugin.Aligner(optionParser.options)

            try:
               plugin = findPlugin(optionParser.options.sampler, 'SAP.sampler')
            except PluginNotFoundError:
               exec("from SAP.Sampling import %s as plugin" % optionParser.options.sampler)
            sampler = plugin.Sampler(optionParser.options)
    
            uniqueDict = {}
            copyLaterDict = {}
    
            # For each fasta file execute pipeline
            for fastaFileName in inputFiles:
    
                fastaFile = open(fastaFileName, 'r')
                fastaIterator = Fasta.Iterator(fastaFile, parser=Fasta.RecordParser())
                fastaFileBaseName = os.path.splitext(os.path.basename(fastaFileName))[0]
                fastaFileBaseNames.append(fastaFileBaseName)
    
                if abortEvent():
                    return jobID
                
                for fastaRecord in fastaIterator:
    
                    homolcompiler = HomolCompiler(optionParser.options)
                    
                    # Discard the header except for the first id word:
                    fastaRecord.title = re.search(r'^(\S+)', fastaRecord.title).group(1)
    
                    print "%s -> %s: " % (fastaFileBaseName, fastaRecord.title)
    
                    # See if the sequence is been encountered before and if so skip it for now:
                    if uniqueDict.has_key(fastaRecord.sequence):
                        copyLaterDict.setdefault(uniqueDict[fastaRecord.sequence], []).append('%s_%s' % (fastaFileBaseName, fastaRecord.title))
                        print '\tsequence double - skipping...\n'
                        continue
                    else:
                        uniqueDict[fastaRecord.sequence] = '%s_%s' % (fastaFileBaseName, fastaRecord.title)
    
                    # Find homologues: Fasta files and pickled homologyResult objects are written to homologcache
                    homologyResult = homolcompiler.compileHomologueSet(fastaRecord, fastaFileBaseName)

                    if abortEvent():
                        return jobID
    
                    if homologyResult != None:
                        # The homologyResult object serves as a job carrying the relevant information.

                        aligner.align(os.path.join(optionParser.options.homologcache, homologyResult.homologuesFileName))
    
                        if abortEvent():
                            return jobID

                        sampler.run(os.path.join(optionParser.options.alignmentcache, homologyResult.alignmentFileName))
    
                        if abortEvent():
                            return jobID
    
                        treeStatistics = TreeStatistics(optionParser.options)
                        treeStatistics.runTreeStatistics([os.path.join(optionParser.options.homologcache, homologyResult.homologuesPickleFileName)], generateSummary=False)
    
            if abortEvent():
                return jobID
    
            # Calculate the pairwise differences between sequences in each file:
            if optionParser.options.diffs:
                pairwisediffs = PairWiseDiffs(optionParser.options)
                pairwisediffs.runPairWiseDiffs(inputFiles)
                #runPairWiseDiffs(inputFiles)
    
            if abortEvent():
                return jobID
    
    
            # Make dictionary to map doubles the ones analyzed:
            doubleToAnalyzedDict = {}
            for k, l in copyLaterDict.items():
                doubleToAnalyzedDict.update(dict([[v,k] for v in l]))
    
            if not optionParser.options.nocopycache and len(doubleToAnalyzedDict):
                # Copy cache files for sequences that occoured more than once:
                print "Copying cached results for %d doubles" % len(doubleToAnalyzedDict)
                copyCacheForSequenceDoubles(copyLaterDict, optionParser.options)
                
            # Calculate the pairwise differences between sequences in each file:
            if optionParser.options.diffs:
                pairwisediffs = PairWiseDiffs(optionParser.options)
                pairwisediffs.runPairWiseDiffs(args)
                #runPairWiseDiffs(args)
    
            # Summary tree stats:
            print 'Computing tree statistics summary...'
            treeStatistics = TreeStatistics(optionParser.options)
            treeStatistics.runTreeStatistics(inputFiles, generateSummary=True, doubleToAnalyzedDict=doubleToAnalyzedDict)
            print "done"
    
            if abortEvent():
                return jobID
    
            # Make HTML output:
            print '\tGenerating HTML output...'
    
            resultHTML = ResultHTML(optionParser.options)
            resultHTML.webify([optionParser.options.treestatscache + '/summary.pickle'], fastaFileBaseNames, doubleToAnalyzedDict, sequenceNameMap)
            print 'done'
    
            return jobID

        except SystemExit, exitVal:
            sys.exit(exitVal)
        except Exception, exe: 
            print """
## SAP crached, sorry ###############################################
Help creating a more stable program by sending the debugging informaion
listed below to kaspermunch@gmail.com along with *.sap file in the project
folder and the sequence input file used.
"""
            print "".join(traceback.format_tb(sys.exc_info()[2]))
            print exe
            raise Exception
    
# 
#         # Summary tree stats:
#         print 'Computing tree statistics summary...'
#         treeStatistics = TreeStatistics(optionParser.options)
#         treeStatistics.runTreeStatistics(inputFiles, generateSummary=True)
#         print "done"
# 
#         if abortEvent():
#             return jobID
# 
#         # Make HTML output:
#         print '\tGenerating HTML output...'
#         resultHTML = ResultHTML(optionParser.options)
#         resultHTML.webify([optionParser.options.treestatscache + '/summary.pickle'], fastaFileBaseNames)
#         print 'done'
# 
#         return jobID

    def onAbortButton(self, event): 
        """Abort the result computation."""
        print "\n[Aborting cleanly: the analysis is aborted after completion of current subtask...]\n"
        self.abortB.Enable(False)
        self.abortEvent.set()
        dlg = wx.MessageDialog(self, 'Analysis is aborting after completion of next sub-task. This is ensures that all retrievals and computations are cached. If you want to discard the analysis altogether quit SAP.\n\nIf you want to force abortion you have to quit SAP.', 'Aborting.', wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()
        
    def _resultConsumer(self, delayedResult):
        jobID = delayedResult.getJobID()
        assert jobID == self.jobID
        try:
            result = delayedResult.get()
        except Exception, exc:
            traceback.print_tb(sys.exc_info()[2])
            print "Result for job %s raised exception: %s" % (jobID, exc)
            return
                
        # get ready for next job:
        self.runB.Enable(True)
        self.runB.SetDefault()
        self.optionsB.Enable(True)
        self.b1.Enable(True)
        self.b2.Enable(True)
        self.t1.Enable(True)
        self.t2.Enable(True)
        self.abortB.Enable(False)

        self.resultPath =  os.path.join(optionParser.options.resultdir, 'index.html')
        self.showResults(None)

                
    def onRunButton(self, evt):

        global optionParser
        inputFiles = re.split(r'\s+', self.t1.GetValue().strip())

        optionParser.options.project = self.t2.GetValue()

        if not inputFiles or not optionParser.options.project:
            dlg = wx.MessageDialog(self, 'You need to specify an input sequence file and a project folder before you can start the analysis',
                                   'Missing input information.',
                                   wx.OK | wx.ICON_ERROR
                                   #wx.YES_NO | wx.NO_DEFAULT | wx.CANCEL | wx.ICON_INFORMATION
                                   #wx.OK | wx.ICON_INFORMATION
                                   )
            dlg.ShowModal()
            dlg.Destroy()
            return

        optionParser.postProcess(guiParent=self)

        self.logframe.Show(True)

        self.runB.Enable(False)
        self.optionsB.Enable(False)
        self.b1.Enable(False)
        self.b2.Enable(False)
        self.t1.Enable(False)
        self.t2.Enable(False)
        self.abortB.Enable(True)
        self.abortB.SetDefault()
        self.abortEvent.clear()
        self.jobID += 1
        delayedresult.startWorker(self._resultConsumer, self._resultProducer, 
                                  wargs=(self.jobID, self.abortEvent, inputFiles), jobID=self.jobID)

    def onOptionsButton(self, evt):

        dlg = OptionsDialog(self)
        dlg.CenterOnScreen()

        # this does not return until the dialog is closed.
        val = dlg.ShowModal()
    
        ## if val == wx.ID_OK:
        ##     print "You pressed OK\n"
        ## else:
        ##     print "You pressed Cancel\n"

        dlg.Destroy()

    def showResults(self, evt):
        global optionParser

        if not self.resultPath:
            projectDir = optionParser.options.project = self.t2.GetValue()
            self.resultPath =  os.path.join(projectDir, optionParser.options.resultdir, 'index.html')
            
        if self.resultPath and os.path.exists(self.resultPath):

            resultLink = hyperlink.HyperLinkCtrl(self, wx.ID_ANY, "", URL="")
        
            strs = "Open results in current default browser? "
            strs = strs + "(Looks best in Firefox or Safari)"
            nResult = wx.MessageBox(strs, "View results", wx.OK |
                                    wx.CANCEL | wx.ICON_QUESTION, self)

            resultURL = 'file://' + self.resultPath
            if nResult == wx.OK:
                resultLink.GotoURL(resultURL, True, True)
        else:
            wx.MessageBox("No results generated yet. You will be notivied when the analysis completes.", "Mesasge")
                        
    def menu203(self, evt):
        self.logframe.Show(True)
        pass

    def menu301(self, evt):

       resultLink = hyperlink.HyperLinkCtrl(self, wx.ID_ANY, "", URL="")
       resultLink.GotoURL(self.webSite, True, False)
        
    def menu302(self, evt):
        # First we create and fill the info object
        info = wx.AboutDialogInfo()
        #info.SetIcon(wx.Icon('/Users/kasper/Desktop/happy48.png', wx.BITMAP_TYPE_PNG))
        info.Name = "SAP"
        info.Version = "1.0"
        info.Copyright = "(C) 2006 Kasper Munch"
        info.Description = wordwrap(
            "SAP is a program for statistical assingment of a unknown"
            "DNA sequence to taxa represented by sequences in GenBank."
            "\n\nIt uses a Bayesian appraoch to estimate a posterior probability of assignment.",
            350, wx.ClientDC(self))
        info.WebSite = (self.webSite, "SAP Homepage")
        info.Developers = [ "Kasper Munch",
                            "Wouter Boomsma",
                            "John Huelsenbeck"]
        licenseText = "blah " * 250
        info.License = wordwrap(licenseText, 500, wx.ClientDC(self))
        # Then we call wx.AboutBox giving it that info object
        wx.AboutBox(info)


    def OnCloseMe(self, event):
        self.Close(True)

    def OnCloseWindow(self, event):
        self.Destroy()


    def onFileBrowseButton(self,evt):

        # Create the dialog. In this case the current directory is forced as the starting
        # directory for the dialog, and no default file name is forced. This can easilly
        # be changed in your program. This is an 'open' dialog, and allows multitple
        # file selections as well.
        #
        # Finally, if the directory is changed in the process of getting files, this
        # dialog is set up to change the current working directory to the path chosen.
        dlg = wx.FileDialog(
            self, message="Choose a file",
            defaultDir=os.getcwd(), 
            defaultFile="",
            wildcard=wildcard,
            style=wx.OPEN | wx.MULTIPLE | wx.CHANGE_DIR
            )

        # Show the dialog and retrieve the user response. If it is the OK response, 
        # process the data.
        if dlg.ShowModal() == wx.ID_OK:
            # This returns a Python list of files that were selected.
            paths = dlg.GetPaths()
            self.inputFiles = paths
            #self.t1.Clear()
            self.t1.WriteText("\n".join(paths))
            #print 'You selected %d files:' % len(paths)

            inputFiles = paths

        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

    def onDirBrowseButton(self, evt):

        global optionParser

        # In this case we include a "New directory" button. 
        dlg = wx.DirDialog(self, "Choose a directory:",
                          style=wx.DD_DEFAULT_STYLE
                           #| wx.DD_DIR_MUST_EXIST
                           #| wx.DD_CHANGE_DIR
                           )

        # If the user selects OK, then we process the dialog's data.
        # This is done by getting the path data from the dialog - BEFORE
        # we destroy it. 
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.t2.Clear()
            self.t2.WriteText(path)
            optionParser.options.project = path
            
        # Only destroy a dialog after you're done with it.
        dlg.Destroy()

    def onSaveFileButton(self, evt):

        # Create the dialog. In this case the current directory is forced as the starting
        # directory for the dialog, and no default file name is forced. This can easilly
        # be changed in your program. This is an 'save' dialog.
        #
        # Unlike the 'open dialog' example found elsewhere, this example does NOT
        # force the current working directory to change if the user chooses a different
        # directory than the one initially set.
        dlg = wx.FileDialog(
            self, message="Save file as ...", defaultDir=os.getcwd(), 
            defaultFile="", wildcard=wildcard, style=wx.SAVE
            )

        # This sets the default filter that the user will initially see. Otherwise,
        # the first filter in the list will be used by default.
        dlg.SetFilterIndex(2)

        # Show the dialog and retrieve the user response. If it is the OK response, 
        # process the data.
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()

            # Normally, at this point you would save your data using the file and path
            # data that the user provided to you, but since we didn't actually start
            # with any data to work with, that would be difficult.
            # 
            # The code to do so would be similar to this, assuming 'data' contains
            # the data you want to save:
            #
            # fp = file(path, 'w') # Create file anew
            # fp.write(data)
            # fp.close()
            #
            # You might want to add some error checking :-)
            #

        # Destroy the dialog. Don't do this until you are done with it!
        # BAD things can happen otherwise!
        dlg.Destroy()

class MyApp(wx.App):

#     def OnPreInit(self):
# 
#         ###########################
#         optionParser.options.project = '/Users/kasper/Desktop/guitest'
#         optionParser.postProcess()
#         from SAP.Sampling import Barcoder as plugin
#         sampler = plugin.Sampler(optionParser.options)
#         sampler.run('/Users/kasper/Desktop/guitest/alignmentcache/test_50262771_sediment_one.nex')
#         sys.exit()
#         ###########################

    def OnInit(self):

        wx.InitAllImageHandlers()
        frame_1 = MyFrame(None, -1, "")
        frame_1.CenterOnScreen()
        self.SetTopWindow(frame_1)

        assertNetblastInstalled(guiParent=frame_1)
        assertClustalw2Installed(guiParent=frame_1)

#         dlg = wx.MessageDialog(frame_1, str(os.environ['PATH']), 'TESTING', wx.OK | wx.ICON_INFORMATION)
#         dlg.ShowModal()
#         dlg.Destroy()

        frame_1.Show()
        return 1
    
    def OpenFileMessage(self, filename):
        dlg = wx.MessageDialog(None,
                               "This app was just asked to open:\n%s\n"%filename,
                               "File Dropped",
                               wx.OK|wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()

    def MacOpenFile(self, filename):
        print filename
        print "%s dropped on app"%(filename) #code to load filename goes here.
        self.OpenFileMessage(filename)

def start_gui():
    app = MyApp(0)
    app.MainLoop()

if __name__ == "__main__":

   start_gui()
